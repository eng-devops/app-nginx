# Pipeline DEPLOY: depende do Build (workflow_run). Seta imagem = nome:tag do repositório da app.
# Regras de branch: feature/* -> dev | release/* -> stg | main -> prd

name: Deploy

on:
  workflow_run:
    workflows: [Build]
    types:
      - completed
    branches:
      - main
      - 'feature/*'
      - 'release/*'

jobs:
  deploy:
    name: Deploy to Kubernetes
    runs-on: [self-hosted, linux]
    if: github.event.workflow_run.conclusion == 'success'
    permissions:
      contents: read
      packages: read   # necessário para o cluster poder pull da imagem no GHCR

    env:
      REGISTRY: ghcr.io
      HELM_TEMPLATES_REPO: eng-devops/helm-templates
      CHART_APP: nginx

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_branch }}

      - name: Checkout helm-templates
        uses: actions/checkout@v4
        with:
          repository: ${{ env.HELM_TEMPLATES_REPO }}
          path: helm-templates
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determined Environment
        id: set-env
        run: |
          BRANCH="${{ github.event.workflow_run.head_branch }}"
          if [[ "$BRANCH" == "main" ]]; then ENV="prd"
          elif [[ "$BRANCH" =~ ^release/ ]]; then ENV="stg"
          elif [[ "$BRANCH" =~ ^feature/ ]]; then ENV="dev"
          else echo "Branch não mapeada: $BRANCH"; exit 1; fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "namespace=$ENV" >> $GITHUB_OUTPUT
          echo "Deploy: $BRANCH -> $ENV"

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: Cluster Access
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Create imagePullSecret
        run: |
          NAMESPACE="${{ steps.set-env.outputs.namespace }}"
          kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
          kubectl create secret docker-registry ghcr-pull-secret \
            --docker-server=ghcr.io \
            --docker-username="${{ github.actor }}" \
            --docker-password="${{ secrets.GITHUB_TOKEN }}" \
            -n "$NAMESPACE" \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "imagePullSecret ghcr-pull-secret criado/atualizado em $NAMESPACE"

      - name: Install Or Upgrade 
        run: |
          # Tag da imagem = env-SHA (mesmo SHA do Build que disparou este workflow)
          HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
          NEW_TAG="${{ steps.set-env.outputs.environment }}-${HEAD_SHA:0:7}"
          IMAGE_NAME="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ github.event.repository.name }}:$NEW_TAG"
          RELEASE="${{ env.CHART_APP }}-${{ steps.set-env.outputs.environment }}"
          NAMESPACE="${{ steps.set-env.outputs.namespace }}"
          VALUES_BASE="helm-templates/apps/${{ env.CHART_APP }}/values.yaml"
          VALUES_ENV="helm-templates/apps/${{ env.CHART_APP }}/${{ steps.set-env.outputs.environment }}/values.yaml"

          cd helm-templates/apps/${{ env.CHART_APP }} && helm dependency update && cd ../../..

          # Se o release existe mas recursos foram deletados no cluster (ex: "services ... not found"),
          # --force recria os recursos. Em falha de upgrade, --cleanup-on-fail limpa recursos criados.
          helm upgrade --install "$RELEASE" helm-templates/apps/${{ env.CHART_APP }} \
            -f "$VALUES_BASE" -f "$VALUES_ENV" \
            --set library-web.image.repositoryOverride="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ github.event.repository.name }}" \
            --set library-web.image.tagOverride="$NEW_TAG" \
            --set library-web.imagePullSecrets[0].name=ghcr-pull-secret \
            -n "$NAMESPACE" --create-namespace \
            --wait --timeout 5m \
            --force \
            --cleanup-on-fail

          echo "Deploy concluído: $RELEASE (imagem: $IMAGE_NAME)"
          helm list -n "$NAMESPACE"