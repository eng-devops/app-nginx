# Pipeline DEPLOY: depende do Build (workflow_run). Seta imagem = nome:tag do repositório da app.
# Regras: feature/* -> dev | release/* -> stg | main -> prd (Blue) | develop -> prd (Green)
# prd usa blue/green: PR release/* -> develop = deploy Green | PR develop -> main = deploy Blue

name: Deploy

on:
  workflow_run:
    workflows: [Build]
    types:
      - completed
    branches:
      - main
      - develop
      - 'feature/*'
      - 'release/*'

jobs:
  # Só segue com deploy se a branch que disparou o Build ainda existir (evita rodar ao excluir feature/* ou release/*).
  check-branch:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success'
    # necessário para verificar se a branch ainda existe
    permissions:
      contents: read
    # necessário para o output branch_exists
    outputs:
      branch_exists: ${{ steps.check.outputs.branch_exists }}
    steps:
      - name: Verificar se a branch ainda existe
        id: check
        run: |
          BRANCH="${{ github.event.workflow_run.head_branch }}"
          # Branch com / precisa ser codificada na URL
          BRANCH_ENC=$(printf '%s' "$BRANCH" | jq -sRr @uri)
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/branches/${BRANCH_ENC}")
          if [[ "$STATUS" == "200" ]]; then
            echo "branch_exists=true" >> $GITHUB_OUTPUT
            echo "Branch $BRANCH existe. Deploy será executado."
          else
            echo "branch_exists=false" >> $GITHUB_OUTPUT
            echo "Branch $BRANCH não existe (excluída ou inexistente). Deploy ignorado."
          fi

  deploy:
    name: Deploy to Kubernetes (${{ github.event.workflow_run.head_branch == 'main' && 'Blue' || github.event.workflow_run.head_branch == 'develop' && 'Green' || startsWith(github.event.workflow_run.head_branch, 'release/') && 'Stg' || 'Dev' }})
    runs-on: [self-hosted, linux]
    needs: check-branch
    if: github.event.workflow_run.conclusion == 'success' && needs.check-branch.outputs.branch_exists == 'true'
    permissions:
      # necessário para verificar se a branch ainda existe
      contents: read
      # necessário para o cluster poder pull da imagem no GHCR
      packages: read   

    env:
      REGISTRY: ghcr.io
      HELM_TEMPLATES_REPO: eng-devops/helm-templates
      CHART_APP: nginx

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_branch }}

      - name: Checkout helm-templates
        uses: actions/checkout@v4
        with:
          repository: ${{ env.HELM_TEMPLATES_REPO }}
          path: helm-templates
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determined Environment
        id: set-env
        run: |
          BRANCH="${{ github.event.workflow_run.head_branch }}"
          SLOT=""
          if [[ "$BRANCH" == "main" ]]; then ENV="prd"; SLOT="blue"
          elif [[ "$BRANCH" == "develop" ]]; then ENV="prd"; SLOT="green"
          elif [[ "$BRANCH" =~ ^release/ ]]; then ENV="stg"
          elif [[ "$BRANCH" =~ ^feature/ ]]; then ENV="dev"
          else echo "Branch não mapeada: $BRANCH"; exit 1; fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "namespace=$ENV" >> $GITHUB_OUTPUT
          echo "slot=$SLOT" >> $GITHUB_OUTPUT
          echo "Deploy: $BRANCH -> $ENV${SLOT:+ (slot: $SLOT)}"

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: Cluster Access
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Create imagePullSecret
        env:
          # PAT com read:packages evita 403 quando vários pods puxam em paralelo (rate limit do GITHUB_TOKEN).
          # Opcional: criar secret GHCR_PULL_TOKEN no repositório com um PAT; senão usa GITHUB_TOKEN.
          GHCR_USER: ${{ github.actor }}
          GHCR_PULL_TOKEN: ${{ secrets.GHCR_PULL_TOKEN }}
          GITHUB_TOKEN_FALLBACK: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NAMESPACE="${{ steps.set-env.outputs.namespace }}"
          GHCR_PASS="${GHCR_PULL_TOKEN:-$GITHUB_TOKEN_FALLBACK}"
          kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
          kubectl create secret docker-registry ghcr-pull-secret \
            --docker-server=ghcr.io \
            --docker-username="$GHCR_USER" \
            --docker-password="$GHCR_PASS" \
            -n "$NAMESPACE" \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "imagePullSecret ghcr-pull-secret criado/atualizado em $NAMESPACE"

      - name: Helm Release Install
        id: helm-release
        run: |
          HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
          NEW_TAG="${{ steps.set-env.outputs.environment }}-${HEAD_SHA:0:7}"
          IMAGE_NAME="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ github.event.repository.name }}:$NEW_TAG"
          NAMESPACE="${{ steps.set-env.outputs.namespace }}"
          SLOT="${{ steps.set-env.outputs.slot }}"

          # Em prd: só existem slots (blue/green). Nunca fazer deploy de release "nginx-prd" com Deployment completo.
          # main -> RELEASE=nginx-prd-blue | develop -> RELEASE=nginx-prd-green | dev/stg -> nginx-dev / nginx-stg
          if [[ -n "$SLOT" ]]; then
            RELEASE="${{ env.CHART_APP }}-${{ steps.set-env.outputs.environment }}-$SLOT"
          else
            RELEASE="${{ env.CHART_APP }}-${{ steps.set-env.outputs.environment }}"
          fi

          VALUES_BASE="helm-templates/apps/${{ env.CHART_APP }}/values.yaml"
          VALUES_ENV="helm-templates/apps/${{ env.CHART_APP }}/${{ steps.set-env.outputs.environment }}/values.yaml"

          cd helm-templates/apps/${{ env.CHART_APP }} && helm dependency update && cd ../../..

          # prd blue/green: slots não criam Ingress; só o router (nginx-prd) cria. Um único deploy por run: slot + router.
          HELM_SET_SLOT=""
          if [[ -n "$SLOT" ]]; then
            HELM_SET_SLOT="--set library-web.ingress.enabled=false"
          fi
          helm upgrade --install "$RELEASE" helm-templates/apps/${{ env.CHART_APP }} \
            -f "$VALUES_BASE" -f "$VALUES_ENV" \
            $HELM_SET_SLOT \
            --set library-web.image.repositoryOverride="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ github.event.repository.name }}" \
            --set library-web.image.tagOverride="$NEW_TAG" \
            --set library-web.imagePullSecrets[0].name=ghcr-pull-secret \
            -n "$NAMESPACE" --create-namespace \
            --wait --timeout 5m \
            --force \
            --cleanup-on-fail

          # prd blue/green: atualizar router Service para apontar para o slot que acabou de receber o deploy
          if [[ -n "$SLOT" ]]; then
            ROUTER_RELEASE="${{ env.CHART_APP }}-${{ steps.set-env.outputs.environment }}"
            helm upgrade --install "$ROUTER_RELEASE" helm-templates/apps/${{ env.CHART_APP }} \
              -f "$VALUES_BASE" -f "$VALUES_ENV" \
              --set library-web.blueGreen.routerService=true \
              --set library-web.blueGreen.targetRelease="$RELEASE" \
              --set library-web.fullnameOverride="$ROUTER_RELEASE" \
              --set library-web.namespaceOverride="$NAMESPACE" \
              -n "$NAMESPACE" --create-namespace
          fi

          echo "RELEASE=$RELEASE" >> $GITHUB_OUTPUT
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Avalability Deploy
        run: |
          NAMESPACE="${{ steps.set-env.outputs.namespace }}"
          RELEASE="${{ steps.helm-release.outputs.RELEASE }}"
          IMAGE_NAME="${{ steps.helm-release.outputs.IMAGE_NAME }}"
          echo "Aguardando pods do release $RELEASE ficarem Ready..."
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/instance="$RELEASE" \
            -n "$NAMESPACE" \
            --timeout=300s
          READY=$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/instance="$RELEASE" --no-headers 2>/dev/null | grep -c Running || echo 0)
          echo ""
          echo "=============================================="
          echo "Deploy concluído: $RELEASE"
          echo "Imagem: $IMAGE_NAME"
          echo "Pods Ready: $READY"
          echo "=============================================="
          