# Pipeline DEPLOY: depende do Build (workflow_run). Seta imagem = nome:tag do repositório da app.
# Regras: feature/* -> dev | release/* -> stg | main -> prd (Blue) | develop -> prd (Green)
# prd usa blue/green: PR release/* -> develop = deploy Green | PR develop -> main = deploy Blue

name: Deploy to Kubernetes

on:
  workflow_run:
    workflows: [Build]
    types:
      - completed
    branches:
      - main
      - develop
      - 'feature/*'
      - 'release/*'

jobs:
  deploy:
    name: Deploy to Kubernetes
    runs-on: [self-hosted, linux]
    if: github.event.workflow_run.conclusion == 'success'
    permissions:
      contents: read
      packages: read  

    env:
      REGISTRY: ghcr.io
      HELM_TEMPLATES_REPO: eng-devops/helm-templates
      CHART_APP: nginx

    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 0

      - name: Checkout helm-templates
        uses: actions/checkout@v4
        with:
          repository: ${{ env.HELM_TEMPLATES_REPO }}
          path: helm-templates
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determined Environment
        id: set-env
        run: |
          BRANCH="${{ github.event.workflow_run.head_branch }}"
          SLOT=""
          if [[ "$BRANCH" == "main" ]]; then ENV="prd"; SLOT="blue"
          elif [[ "$BRANCH" == "develop" ]]; then ENV="prd"; SLOT="green"
          elif [[ "$BRANCH" =~ ^release/ ]]; then ENV="stg"
          elif [[ "$BRANCH" =~ ^feature/ ]]; then ENV="dev"
          else echo "Branch não mapeada: $BRANCH"; exit 1; fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "namespace=$ENV" >> $GITHUB_OUTPUT
          echo "slot=$SLOT" >> $GITHUB_OUTPUT
          echo "Deploy: $BRANCH -> $ENV${SLOT:+ (slot: $SLOT)}"

      - name: Final Tag 
        id: semver
        if: github.event.workflow_run.head_branch == 'main' || github.event.workflow_run.head_branch == 'develop' || startsWith(github.event.workflow_run.head_branch, 'release/')
        run: |
          BRANCH="${{ github.event.workflow_run.head_branch }}"
          # Última tag que é ancestral do commit (a tag que veio da develop/release)
          LATEST_TAG=$(git tag -l 'v*' --merged HEAD 2>/dev/null | sort -V | tail -1 || true)
          if [[ -z "$LATEST_TAG" ]]; then
            echo "Nenhuma tag encontrada, deploy usará env-sha"
            exit 0
          fi
          VERSION="${LATEST_TAG#v}"
          # Em main: usar versão final removendo o sufixo -rc
          if [[ "$BRANCH" == "main" && "$VERSION" == *-rc* ]]; then
            VERSION="${VERSION%-rc*}"
            echo "Versão final (main): $VERSION"
          else
            echo "Tag da branch: $VERSION"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: Cluster Access
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Create imagePullSecret
        env:
          GHCR_USER: ${{ github.actor }}
          GHCR_PASS: ${{ secrets.GHCR_PULL_TOKEN }}
        run: |
          NAMESPACE="${{ steps.set-env.outputs.namespace }}"
          kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
          kubectl create secret docker-registry ghcr-pull-secret \
            --docker-server=ghcr.io \
            --docker-username="$GHCR_USER" \
            --docker-password="$GHCR_PASS" \
            -n "$NAMESPACE" \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "imagePullSecret ghcr-pull-secret criado/atualizado em $NAMESPACE"

      - name: Helm Release Install
        id: helm-release
        run: |
          HEAD_SHA="${{ github.event.workflow_run.head_sha }}"
          # main/release: tag da imagem = versão semântica; demais branches = env-sha
          if [[ -n "${{ steps.semver.outputs.version }}" ]]; then
            NEW_TAG="${{ steps.semver.outputs.version }}"
          else
            NEW_TAG="${{ steps.set-env.outputs.environment }}-${HEAD_SHA:0:7}"
          fi
          IMAGE_NAME="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ github.event.repository.name }}:$NEW_TAG"
          NAMESPACE="${{ steps.set-env.outputs.namespace }}"
          SLOT="${{ steps.set-env.outputs.slot }}"

          # prd blue/green: release = nginx-prd-blue ou nginx-prd-green; caso contrário nginx-<env>
          if [[ -n "$SLOT" ]]; then
            RELEASE="${{ env.CHART_APP }}-${{ steps.set-env.outputs.environment }}-$SLOT"
          else
            RELEASE="${{ env.CHART_APP }}-${{ steps.set-env.outputs.environment }}"
          fi

          VALUES_BASE="helm-templates/apps/${{ env.CHART_APP }}/values.yaml"
          VALUES_ENV="helm-templates/apps/${{ env.CHART_APP }}/${{ steps.set-env.outputs.environment }}/values.yaml"

          cd helm-templates/apps/${{ env.CHART_APP }} && helm dependency update && cd ../../..

          # Em prd instala-se apenas o slot (nginx-prd-blue ou nginx-prd-green); slots sem Ingress (evita conflito).
          HELM_SET_SLOT=""
          if [[ -n "$SLOT" ]]; then
            HELM_SET_SLOT="--set library-web.ingress.enabled=false"
          fi
          helm upgrade --install "$RELEASE" helm-templates/apps/${{ env.CHART_APP }} \
            -f "$VALUES_BASE" -f "$VALUES_ENV" \
            $HELM_SET_SLOT \
            --set library-web.image.repositoryOverride="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ github.event.repository.name }}" \
            --set library-web.image.tagOverride="$NEW_TAG" \
            --set library-web.imagePullSecrets[0].name=ghcr-pull-secret \
            -n "$NAMESPACE" --create-namespace \
            --wait --timeout 5m \
            --force \
            --cleanup-on-fail
          echo "====================================================================="
          echo "Deploy concluído: $RELEASE (imagem: $IMAGE_NAME)"
          echo "====================================================================="

